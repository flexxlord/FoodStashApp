import { logger } from "@sentry/utils";
import { RoutingInstrumentation, } from "./routingInstrumentation";
const STATE_CHANGE_TIMEOUT_DURATION = 200;
/**
 * Instrumentation for React-Navigation V5. See docs or sample app for usage.
 *
 * How this works:
 * - `_onDispatch` is called every time a dispatch happens and sets an IdleTransaction on the scope without any route context.
 * - `_onStateChange` is then called AFTER the state change happens due to a dispatch and sets the route context onto the active transaction.
 * - If `_onStateChange` isn't called within `STATE_CHANGE_TIMEOUT_DURATION` of the dispatch, then the transaction is not sampled and finished.
 */
export class ReactNavigationV5Instrumentation extends RoutingInstrumentation {
    constructor() {
        super(...arguments);
        this._navigationContainerRef = {
            current: null,
        };
        this._maxRecentRouteLen = 200;
        this._shouldUpdateLatestTransactionOnRef = false;
        this._recentRouteKeys = [];
        /** Pushes a recent route key, and removes earlier routes when there is greater than the max length */
        this._pushRecentRouteKey = (key) => {
            this._recentRouteKeys.push(key);
            if (this._recentRouteKeys.length > this._maxRecentRouteLen) {
                this._recentRouteKeys = this._recentRouteKeys.slice(this._recentRouteKeys.length - this._maxRecentRouteLen);
            }
        };
    }
    /**
     * Extends by calling _handleInitialState at the end.
     */
    registerRoutingInstrumentation(listener, beforeNavigate) {
        super.registerRoutingInstrumentation(listener, beforeNavigate);
        // Need to handle the initial state as the navigation container listeners will only start transactions on subsequent route changes.
        this._handleInitialState();
    }
    /**
     * Pass the ref to the navigation container to register it to the instrumentation
     * @param navigationContainerRef Ref to a `NavigationContainer`
     */
    registerNavigationContainer(navigationContainerRef) {
        var _a, _b;
        this._navigationContainerRef = navigationContainerRef;
        (_a = navigationContainerRef.current) === null || _a === void 0 ? void 0 : _a.addListener("__unsafe_action__", // This action is emitted on every dispatch
        this._onDispatch.bind(this));
        (_b = navigationContainerRef.current) === null || _b === void 0 ? void 0 : _b.addListener("state", // This action is emitted on every state change
        this._onStateChange.bind(this));
        if (this._shouldUpdateLatestTransactionOnRef) {
            this._onStateChange();
            this._shouldUpdateLatestTransactionOnRef = false;
        }
    }
    /**
     *
     */
    _handleInitialState() {
        // This will set a transaction for the initial screen.
        this._onDispatch();
        this._shouldUpdateLatestTransactionOnRef = true;
    }
    /**
     * To be called on every React-Navigation action dispatch.
     * It does not name the transaction or populate it with route information. Instead, it waits for the state to fully change
     * and gets the route information from there, @see _onStateChange
     */
    _onDispatch() {
        this._latestTransaction = this.onRouteWillChange(BLANK_TRANSACTION_CONTEXT_V5);
        this._stateChangeTimeout = setTimeout(this._discardLatestTransaction.bind(this), STATE_CHANGE_TIMEOUT_DURATION);
    }
    /**
     * To be called AFTER the state has been changed to populate the transaction with the current route.
     */
    _onStateChange() {
        var _a, _b, _c, _d, _e;
        // Use the getCurrentRoute method to be accurate.
        const previousRoute = this._latestRoute;
        const route = (_b = (_a = this._navigationContainerRef) === null || _a === void 0 ? void 0 : _a.current) === null || _b === void 0 ? void 0 : _b.getCurrentRoute();
        if (route) {
            if (this._latestTransaction &&
                (!previousRoute || previousRoute.key !== route.key)) {
                const originalContext = this._latestTransaction.toContext();
                const routeHasBeenSeen = this._recentRouteKeys.includes(route.key);
                const updatedContext = Object.assign(Object.assign({}, originalContext), { name: route.name, tags: Object.assign(Object.assign({}, originalContext.tags), { "routing.route.name": route.name }), data: Object.assign(Object.assign({}, originalContext.data), { route: {
                            name: route.name,
                            key: route.key,
                            params: (_c = route.params) !== null && _c !== void 0 ? _c : {},
                            hasBeenSeen: routeHasBeenSeen,
                        }, previousRoute: previousRoute
                            ? {
                                name: previousRoute.name,
                                key: previousRoute.key,
                                params: (_d = previousRoute.params) !== null && _d !== void 0 ? _d : {},
                            }
                            : null }) });
                let finalContext = (_e = this._beforeNavigate) === null || _e === void 0 ? void 0 : _e.call(this, updatedContext);
                // This block is to catch users not returning a transaction context
                if (!finalContext) {
                    logger.error(`[ReactNavigationV5Instrumentation] beforeNavigate returned ${finalContext}, return context.sampled = false to not send transaction.`);
                    finalContext = Object.assign(Object.assign({}, updatedContext), { sampled: false });
                }
                if (finalContext.sampled) {
                    // Clear the timeout so the transaction does not get cancelled.
                    if (typeof this._stateChangeTimeout !== "undefined") {
                        clearTimeout(this._stateChangeTimeout);
                        this._stateChangeTimeout = undefined;
                    }
                }
                else {
                    logger.log(`[ReactNavigationV5Instrumentation] Will not send transaction "${finalContext.name}" due to beforeNavigate.`);
                }
                this._latestTransaction.updateWithContext(finalContext);
            }
            this._pushRecentRouteKey(route.key);
            this._latestRoute = route;
        }
    }
    /** Cancels the latest transaction so it does not get sent to Sentry. */
    _discardLatestTransaction() {
        if (this._latestTransaction) {
            this._latestTransaction.sampled = false;
            this._latestTransaction.finish();
            this._latestTransaction = undefined;
        }
    }
}
ReactNavigationV5Instrumentation.instrumentationName = "react-navigation-v5";
export const BLANK_TRANSACTION_CONTEXT_V5 = {
    name: "Route Change",
    op: "navigation",
    tags: {
        "routing.instrumentation": ReactNavigationV5Instrumentation.instrumentationName,
    },
    data: {},
};
//# sourceMappingURL=reactnavigationv5.js.map